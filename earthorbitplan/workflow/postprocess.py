#!/usr/bin/env python
"""
postprocess.py : Compute Detection Probabilities and Optimization Metrics
=============================================================================

This script processes observation plans generated by M4OPT, computes detection
probabilities, and extracts optimization metrics.

It supports command-line arguments and `.ini` configuration files.

Usage
-----

Command line:

    python postprocess.py --data-dir data

Configuration file:

    python earthorbitplan/workflow/postprocess.py --config earthorbitplan/config/params_ultrasat.ini

Description
-----------

The script computes the detection probability using `detection_probability.py`,
aggregates simulation data, and saves results in `events.ecsv` (default: ./data).
This output can be used for subsequent statistical analysis.
"""

import argparse
import configparser
import logging
import sys
import warnings
from pathlib import Path

from astropy.table import QTable
from ligo.skymap.util.progress import progress_map

# from ..probability.detection_probability import get_detection_probability_known_position
from earthorbitplan.probability.detection_probability import (
    get_detection_probability_known_position,
)

warnings.filterwarnings("ignore", ".*Wswiglal-redir-stdio.*")
warnings.filterwarnings("ignore", ".*dubious year.*")
warnings.filterwarnings("ignore", ".*polar motions.*")


def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Post-process observation plans generated by M4OPT."
    )
    parser.add_argument("--config", type=str, help="Path to .ini configuration file")

    args, remaining_args = parser.parse_known_args()

    if args.config:
        config = configparser.ConfigParser()
        config.read(args.config)
        cfg = config["params"]
        return argparse.Namespace(
            data_dir=cfg.get("data_dir", fallback="data"),
            event_table=cfg.get("event_table", fallback="observing-scenarios.ecsv"),
            output_file=cfg.get("output_file", fallback="events.ecsv"),
            sched_dir=cfg.get("sched_dir", fallback="schedules"),
        )

    # CLI parsing if no config
    parser.add_argument(
        "--data-dir",
        type=str,
        default="data",
        help="Data directory containing ECSV files",
    )
    parser.add_argument(
        "--event-table",
        type=str,
        default="observing-scenarios.ecsv",
        help="Input summary table",
    )
    parser.add_argument(
        "--output-file", type=str, default="events.ecsv", help="Output filename"
    )
    parser.add_argument(
        "--sched-dir", type=str, default="schedules", help="Directory for schedules"
    )

    return parser.parse_args(remaining_args)


def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)],
        force=True,
    )


def process(row, sched_path):
    """
    Process an event and extract detection probability and optimization metrics.

    Parameters
    ----------
    row : astropy.table.Row
        Row containing event details.
    sched_path : pathlib.Path
        Path to the schedules directory.

    Returns
    -------
    tuple
        Contains, for the given event:
        detection_probability_known_position : float or None
            Detection probability at the known position (or None if missing plan).
        objective_value : float or None
            Optimization objective value from the plan.
        best_bound : float or None
            Best bound found by the optimizer.
        solution_status : str or None
            Status string from the optimization result.
        solution_time : float or None
            Time taken to find the solution (in seconds).
        num_fields : int or None
            Number of fields scheduled for observation (or None if missing).
        cutoff : float
            Cutoff value used for selection (if present in plan).
        nside : int
            HEALPix nside parameter
        mission : str or None
            Mission name/identifier.
        snr : float
            Signal-to-noise ratio threshold.
        deadline : float
            Deadline for the observation plan.
        delay : float or None
            Delay applied before scheduling.
        exptime_min : float
            Minimum exposure time used in the plan.
        exptime_max : float
            Maximum exposure time used in the plan.
        bandpass : str
            Bandpass/filter used in the observations.
        absmag_mean : float
            Mean absolute magnitude of the simulated source.
        absmag_stdev : float or None
            Standard deviation of the absolute magnitude.
        visits : int
            Number of visits per field (as planned).

        All values are None if the schedule file is missing.
    """

    run, event_id = row["run"], row["coinc_event_id"]
    plan_file = sched_path / run / f"{event_id}.ecsv"

    if not plan_file.exists():
        logging.warning(f"Missing schedule file: {plan_file}")
        return (None,) * 18

    plan = QTable.read(plan_file)
    plan_args = plan.meta["args"]
    plan_args.pop("skymap", None)

    return (
        get_detection_probability_known_position(plan, row, plan_args),
        plan.meta.get("objective_value"),
        plan.meta.get("best_bound"),
        plan.meta.get("solution_status"),
        plan.meta.get("solution_time"),
        len(plan[plan["action"] == "observe"]) // plan_args["visits"],
        plan_args.get("cutoff"),
        plan_args.get("nside"),
        plan_args.get("mission"),
        plan_args.get("snr"),
        plan_args.get("deadline"),
        plan_args.get("delay"),
        plan_args.get("exptime_min"),
        plan_args.get("exptime_max"),
        plan_args.get("bandpass"),
        plan_args.get("absmag_mean"),
        plan_args.get("absmag_stdev"),
        plan_args.get("visits"),
    )


def main():
    args = parse_arguments()
    setup_logging()

    base_path = Path(args.data_dir)
    input_path = base_path / args.event_table
    sched_path = base_path / args.sched_dir
    output_path = base_path / args.output_file

    logging.info(f"Loading event table from: {input_path}")
    table = QTable.read(input_path)

    logging.info("Computing detection probabilities and optimization metrics...")
    (
        table["detection_probability_known_position"],
        table["objective_value"],
        table["best_bound"],
        table["solution_status"],
        table["solution_time"],
        table["num_fields"],
        table["cutoff"],
        table["nside"],
        table["mission"],
        table["snr"],
        table["deadline"],
        table["delay"],
        table["exptime_min"],
        table["exptime_max"],
        table["bandpass"],
        table["absmag_mean"],
        table["absmag_stdev"],
        table["visits"],
    ) = zip(*progress_map(lambda row: process(row, sched_path), table))

    logging.info(f"Saving results to: {output_path}")
    table.write(output_path, overwrite=True)


if __name__ == "__main__":
    main()
